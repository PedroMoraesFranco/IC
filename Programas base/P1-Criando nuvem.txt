######################################################################################################################
######################################################## Slab ########################################################
######################################################################################################################

function get_slab(Variaveis_entrada::get_slab_ENTRADA)
    x_atoms = -Variaveis_entrada.X*rand(Variaveis_entrada.N) .+ Variaveis_entrada.X/2; #Atoms positions (x-axis)
    y_atoms = -Variaveis_entrada.Y*rand(Variaveis_entrada.N) .+ Variaveis_entrada.Y/2; #Atoms positions (y-axis)
    r = zeros(Variaveis_entrada.N,2);
    r[:,1] = x_atoms;
    r[:,2] = y_atoms;
    return r
end





######################################################################################################################
####################################################### ESCALAR ######################################################
######################################################################################################################

function get_green_scalar(Variaveis_entrada::get_green_scalar_ENTRADA)
    #k = Variaveis_entrada.k
    G = Array{Complex{Float64}}(undef,Variaveis_entrada.N,Variaveis_entrada.N);
    @. G = SpecialFunctions.besselh(0,1,Variaveis_entrada.k*Variaveis_entrada.rij); # Scalar Green matrix
    G[LinearAlgebra.diagind(G)].= 1; #main diagonal 

    Fator_iΔ = zeros(ComplexF64, N, N)
    Fator_iΔ[LinearAlgebra.diagind(Fator_iΔ)].= 1im*Δ;
    Matrix_G = G*(-Γ₀/2)-Fator_iΔ
    return Matrix_G
end


function get_cloud_escalar(Variaveis_entrada::get_cloud_ENTRADA)
    Entrada_slab = get_slab_ENTRADA(Variaveis_entrada.N,Variaveis_entrada.X,Variaveis_entrada.Y)
    r = get_slab(Entrada_slab)
    rij = Distances.pairwise(Euclidean(), r, r, dims = 1);
    Entrada_green_scalar = get_green_scalar_ENTRADA(Variaveis_entrada.N,Variaveis_entrada.k, rij,Variaveis_entrada.Δ,Variaveis_entrada.Γ₀)
    G = get_green_scalar(Entrada_green_scalar)
    #λ, ψ  = LinearAlgebra.eigen(G); #Eingenvalues and eigensvectors
    return r, rij, G
end


function get_β(Variaveis_entrada::get_β_ENTRADA)
    β = Variaveis_entrada.G\((1im/2)*Variaveis_entrada.EL_atoms)
    return β
end





######################################################################################################################
###################################################### Vetorial ######################################################
######################################################################################################################

function get_Slab(N,X,Y)
    x_atoms = -X*rand(N) .+ X/2; #Atoms positions (x-axis)
    y_atoms = -Y*rand(N) .+ Y/2; #Atoms positions (y-axis)
    r = zeros(N,2);
    r[:,1] = x_atoms;
    r[:,2] = y_atoms;
    return r
end


function get_Φ(r,sensores)
    N = size(r,1)
    Nsensor = size(sensores,1)
    y_sensor = sensores[:,1]
    x_sensor = sensores[:,2]
    x = r[:,1]
    y = r[:,2]
    Φ = zeros(N)
    for i in Nsensor
        for j in N
            Φ = atan(y[j]-y_sensor[i], x[j]-x_sensor[i])        
        end
    end
    return Φ
end


function get_matrix_H0(N,k,rij)
    G = Array{Complex{Float64}}(undef,N,N);
    @. G = SpecialFunctions.besselh(0,1,k*rij); # Scalar Green matrix
    G[LinearAlgebra.diagind(G)].= 1; #main diagonal 
    return G
end


function get_matrix_H2_plus(N,k,rij,Φ)
    G_plus = Array{Complex{Float64}}(undef,N,N);
    @. G_plus = exp(2im*Φ)*SpecialFunctions.besselh(2,1,k*rij);
    G_plus[LinearAlgebra.diagind(G_plus)].= 0; #main diagonal 
    return G_plus
end


function get_matrix_H2_minus(N,k,rij,Φ)
    G_minus = Array{Complex{Float64}}(undef,N,N);
    @. G_minus = exp(-2im*Φ)*SpecialFunctions.besselh(2,1,k*rij);
    G_minus[LinearAlgebra.diagind(G_minus)].= 0; #main diagonal 
    return G_minus
end


function get_green_matrix(N,k,rij,Δ,Γ1,Φ)
    H0 = (-1/2)*get_matrix_H0(N,k,rij)
    H2plus = get_matrix_H2_plus(N,k,rij,Φ)*(1/2)
    H2minus = get_matrix_H2_minus(N,k,rij,Φ)*(1/2)
    G = [H0 H2minus;H2plus H0]
    
    Fator_iΔ = zeros(ComplexF64, 2N, 2N)
    Fator_iΔ[LinearAlgebra.diagind(Fator_iΔ)].= 1im*Δ;
    Matrix_G = G*(Γ1/2)-Fator_iΔ
    return Matrix_G
end


function get_cloud_vetorial(N,k,Δ, Φ,Γ₀, r)
    Γ1=Γ₀/2
    rij = Distances.pairwise(Euclidean(), r, r, dims = 1);
    G = get_green_matrix(N,k,rij,Δ,Γ1,Φ)
    λ, ψ  = LinearAlgebra.eigen(G); #Eingenvalues and eigensvectors
    return rij, G, λ, ψ
end


function get_β(G,EL_atoms)
    β = G\((1im/2)*EL_atoms)
    return β
end